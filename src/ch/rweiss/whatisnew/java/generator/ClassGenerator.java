package ch.rweiss.whatisnew.java.generator;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import org.apache.commons.lang3.ClassUtils;
import org.apache.commons.lang3.StringUtils;

import ch.rweiss.whatisnew.java.WhatIsNewInException;
import ch.rweiss.whatisnew.java.model.ApiClass;
import ch.rweiss.whatisnew.java.model.ApiConstructor;
import ch.rweiss.whatisnew.java.model.ApiMethod;
import ch.rweiss.whatisnew.java.model.Version;

class ClassGenerator
{
  private final ClassName name;
  private final Printer printer;
  private final ApiClass apiClass;
  private boolean needsCreateMethod = false;
  private final Imports imports = new Imports();
  private final List<Version> versions;
  private final List<Method> alreadyGeneratedMethods = new ArrayList<>();

  ClassGenerator(ClassName name, ApiClass apiClass, List<Version> versions, Printer printer)
  {
    this.name = name;
    this.apiClass = apiClass;
    this.versions = versions;
    this.printer = printer;
  }

  boolean generate()
  {
    Class<?> clazz = getJavaClass();
    if (!Modifier.isPublic(clazz.getModifiers()))
    {
      return false;
    }
    
    generatePackage();
    generateImports();
    generateClass();
    return true;
  }

  private void generatePackage()
  {
    printer.print("package ");
    printer.print(name.getGeneratorPackageName());
    printer.print(";");
  }

  private void generateImports()
  {
    printer.println();
    printer.println();
    imports.add(getJavaClass());
    apiClass
        .getMethods()
        .stream()
        .flatMap(this::getTypesToImport)
        .forEach(imports::add);
    imports.forEach(this::generateImport);
    printer.println();
  }
  
  Stream<Class<?>> getTypesToImport(ApiMethod method)
  {
    return new MethodGenerator(this, method).getTypesToImport();
  }
  
  private void generateImport(String className)
  {
    printer.print("import ");
    printer.print(className);
    printer.print(";");
    printer.println();
  }

  private void generateClass()
  {
    generateJavaDoc();
    printer.print("public final class ");
    printer.print(name.getGeneratorSimpleName());
    Class<?> clazz = getJavaClass();
    new TypeVariablesDeclarationGenerator(imports, printer, clazz.getTypeParameters()).generate();
    printer.println();
    printer.print("{");
    printer.println();
    printer.indent(2);
    if (!Modifier.isAbstract(clazz.getModifiers()))
    {
      apiClass.getConstructors().forEach(this::generate);
    }
    apiClass.getMethods().forEach(this::generate);
    generateCreateMethod();
    printer.indent(0);
    printer.print("}");
    printer.println();
  }

  private void generateJavaDoc()
  {
    printer.print("/**");
    printer.println();
    printer.print(" * This source file was generated by WhatIsNewInJava<br>");
    printer.println();
    printer.print(" *");
    printer.println();
    printer.print(" * This class provides an example call to each method in class {@link ");
    printer.print(name.getApiSimpleName());
    printer.print("}");
    printer.println();
    printer.print(" * that were newly introduced in");
    if (versions.isEmpty()) 
    {
      printer.print(" any");
    }
    printer.print(" Java versions ");
    printer.forEachPrint(versions, ", ", version -> printer.print(version));
    printer.print(".<br>");
    printer.println();
    printer.print(" *");
    printer.println();
    printer.print(" * {@link ");
    printer.print(name.getApiSimpleName());
    if (versions.contains(apiClass.getSince()))
    {
      printer.print("} is a completely new class");
    }
    else
    {
      printer.print("} is an old class but has new fields, constructors or methods");
    }
    printer.println();
    printer.print(" * @since ");
    printer.print(apiClass.getSince());
    printer.println();
    printer.print(" * @see ");
    printer.print(name.getApiSimpleName());
    printer.println();
    printer.print(" */");
    printer.println();
  }

  void generate(ApiMethod apiMethod)
  {
    new MethodGenerator(this, apiMethod).generate();
  }

  void generate(ApiConstructor apiConstructor)
  {
    new ConstructorGenerator(this, apiConstructor).generate();
  }

  private void generateCreateMethod()
  {
    if (!needsCreateMethod)
    {
      return;
    }
    printer.print("private <O> O create()");    
    printer.println();
    printer.print("{");
    printer.println();
    printer.indent(4);
    printer.print("return null;");
    printer.println();
    printer.indent(2);
    printer.print("}");
    printer.println();
  }

  Class<?> getJavaClass()
  {
    return getJavaClass(name);
  }
  
  static Class<?> getJavaClass(ClassName name)
  {
    return getJavaClass(name.getApiFullQualifiedName());
  }

  static Class<?> getJavaClass(String fullQualifiedName)
  {
    if (fullQualifiedName.endsWith("..."))
    {
      fullQualifiedName = StringUtils.removeEnd(fullQualifiedName, "...") + "[]";
    }
    try
    {
      return ClassUtils.getClass(fullQualifiedName);
    }
    catch (ClassNotFoundException ex)
    {
      throw new WhatIsNewInException(ex);
    }
  }

  Printer getPrinter()
  {
    return printer;
  }

  boolean methodAlreadyGenerated(Method method)
  {
    return alreadyGeneratedMethods.contains(method);
  }

  void addGeneratedMethod(Method method)
  {
    alreadyGeneratedMethods.add(method);
  }

  ApiClass getApiClass()
  {
    return apiClass;
  }

  Imports getImports()
  {
    return imports;
  }

  void needsCreateMethod()
  {
    needsCreateMethod = true;  
  }

  ClassName getName()
  {
    return this.name;
  }
}
